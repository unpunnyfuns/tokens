/**
 * Functional manifest validation API
 */

import type { UPFTResolverManifest } from "../manifest/upft-types.js";
import type { ValidationError, ValidationResult } from "../types/validation.js";

/**
 * Validate a modifier definition
 */
function validateModifier(
  name: string,
  modifier: unknown,
  errors: ValidationError[],
): void {
  if (!modifier || typeof modifier !== "object") {
    errors.push({
      path: `modifiers.${name}`,
      message: "Modifier must be an object",
      severity: "error",
    });
    return;
  }

  const mod = modifier as Record<string, unknown>;
  const hasOneOf = "oneOf" in mod;
  const hasAnyOf = "anyOf" in mod;

  // Must have exactly one of oneOf or anyOf
  if (!(hasOneOf || hasAnyOf)) {
    errors.push({
      path: `modifiers.${name}`,
      message: "Modifier must have either oneOf or anyOf",
      severity: "error",
    });
  }

  if (hasOneOf && hasAnyOf) {
    errors.push({
      path: `modifiers.${name}`,
      message: "Modifier cannot have both oneOf and anyOf",
      severity: "error",
    });
  }

  // Validate oneOf/anyOf are arrays
  if (hasOneOf && !Array.isArray(mod.oneOf)) {
    errors.push({
      path: `modifiers.${name}.oneOf`,
      message: "oneOf must be an array",
      severity: "error",
    });
  }

  if (hasAnyOf && !Array.isArray(mod.anyOf)) {
    errors.push({
      path: `modifiers.${name}.anyOf`,
      message: "anyOf must be an array",
      severity: "error",
    });
  }

  // Values must be an object
  if (!mod.values || typeof mod.values !== "object") {
    errors.push({
      path: `modifiers.${name}.values`,
      message: "Modifier must have a values object",
      severity: "error",
    });
    return;
  }

  // Check that all options have corresponding values
  const options = (mod.oneOf || mod.anyOf) as unknown[];
  if (Array.isArray(options)) {
    for (const option of options) {
      if (typeof option !== "string") {
        errors.push({
          path: `modifiers.${name}.${hasOneOf ? "oneOf" : "anyOf"}`,
          message: "Options must be strings",
          severity: "error",
        });
        continue;
      }

      if (!(mod.values as Record<string, unknown>)?.[option]) {
        errors.push({
          path: `modifiers.${name}.values.${option}`,
          message: `Missing values for option '${option}'`,
          severity: "error",
        });
      }
    }
  }
}

/**
 * Validate a set definition
 */
function validateSet(
  set: unknown,
  index: number,
  errors: ValidationError[],
): void {
  if (!set || typeof set !== "object") {
    errors.push({
      path: `sets[${index}]`,
      message: "Set must be an object",
      severity: "error",
    });
    return;
  }

  const s = set as Record<string, unknown>;

  // Must have either files or values array
  const hasFiles = "files" in s && Array.isArray(s.files);
  const hasValues = "values" in s && Array.isArray(s.values);

  if (!(hasFiles || hasValues)) {
    errors.push({
      path: `sets[${index}]`,
      message: "Set must have either files or values array",
      severity: "error",
    });
    return;
  }

  // Validate files array
  if (hasFiles) {
    (s.files as unknown[]).forEach((file, fileIndex) => {
      if (typeof file !== "string") {
        errors.push({
          path: `sets[${index}].files[${fileIndex}]`,
          message: "File path must be a string",
          severity: "error",
        });
      }
    });
  }

  // Validate values array
  if (hasValues) {
    (s.values as unknown[]).forEach((value, valueIndex) => {
      if (typeof value !== "string") {
        errors.push({
          path: `sets[${index}].values[${valueIndex}]`,
          message: "Value must be a string (file path)",
          severity: "error",
        });
      }
    });
  }

  // Validate modifiers if present
  if ("modifiers" in s && s.modifiers) {
    if (typeof s.modifiers !== "object") {
      errors.push({
        path: `sets[${index}].modifiers`,
        message: "Modifiers must be an object",
        severity: "error",
      });
    }
  }
}

/**
 * Validate output configuration
 */
function validateOutput(output: unknown, errors: ValidationError[]): void {
  if (!output || typeof output !== "object") {
    errors.push({
      path: "output",
      message: "Output must be an object",
      severity: "error",
    });
    return;
  }

  const out = output as Record<string, unknown>;

  // Validate directory
  if ("directory" in out && typeof out.directory !== "string") {
    errors.push({
      path: "output.directory",
      message: "Output directory must be a string",
      severity: "error",
    });
  }

  // Validate filename pattern
  if ("filename" in out && typeof out.filename !== "string") {
    errors.push({
      path: "output.filename",
      message: "Output filename must be a string",
      severity: "error",
    });
  }

  // Validate merge option
  if ("merge" in out && typeof out.merge !== "boolean") {
    errors.push({
      path: "output.merge",
      message: "Output merge must be a boolean",
      severity: "error",
    });
  }

  // Validate resolveReferences option
  if (
    "resolveReferences" in out &&
    typeof out.resolveReferences !== "boolean"
  ) {
    errors.push({
      path: "output.resolveReferences",
      message: "Output resolveReferences must be a boolean",
      severity: "error",
    });
  }
}

/**
 * Validate a UPFT manifest
 */
export function validateManifest(manifest: unknown): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];

  if (!manifest || typeof manifest !== "object") {
    errors.push({
      path: "/",
      message: "Manifest must be an object",
      severity: "error",
    });
    return { valid: false, errors, warnings };
  }

  const m = manifest as Record<string, unknown>;

  // Validate modifiers
  if ("modifiers" in m) {
    if (!m.modifiers || typeof m.modifiers !== "object") {
      errors.push({
        path: "modifiers",
        message: "Modifiers must be an object",
        severity: "error",
      });
    } else {
      for (const [name, modifier] of Object.entries(m.modifiers)) {
        validateModifier(name, modifier, errors);
      }
    }
  }

  // Validate sets (required)
  if ((("sets" in m) && Array.isArray(m.sets))) {
    m.sets.forEach((set, index) => {
      validateSet(set, index, errors);
    });

    if (m.sets.length === 0) {
      warnings.push({
        path: "sets",
        message: "Sets array is empty",
        severity: "warning",
      });
    }
  } else {
    errors.push({
      path: "sets",
      message: "Manifest must have a sets array",
      severity: "error",
    });
  }

  // Validate output if present
  if ("output" in m && m.output) {
    validateOutput(m.output, errors);
  }

  // Validate options if present
  if ("options" in m && m.options) {
    if (typeof m.options !== "object") {
      errors.push({
        path: "options",
        message: "Options must be an object",
        severity: "error",
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Check if a value is a valid manifest (quick check)
 */
export function isValidManifest(manifest: unknown): boolean {
  if (!manifest || typeof manifest !== "object") return false;

  const m = manifest as Record<string, unknown>;

  // Must have sets array
  if (!(("sets" in m) && Array.isArray(m.sets))) return false;

  // Sets must not be empty
  if (m.sets.length === 0) return false;

  // If modifiers exist, check basic structure
  if ("modifiers" in m && m.modifiers) {
    if (typeof m.modifiers !== "object") return false;

    for (const modifier of Object.values(m.modifiers)) {
      if (!modifier || typeof modifier !== "object") return false;
      const mod = modifier as Record<string, unknown>;

      // Must have oneOf or anyOf
      if (!(("oneOf" in mod) || ("anyOf" in mod))) return false;

      // Must have values
      if (!("values" in mod)) return false;
    }
  }

  return true;
}

/**
 * Validate manifest and return typed result
 */
export function validateAndParseManifest(
  manifest: unknown,
):
  | { valid: true; manifest: UPFTResolverManifest }
  | { valid: false; errors: ValidationError[] } {
  const result = validateManifest(manifest);

  if (result.valid) {
    return { valid: true, manifest: manifest as UPFTResolverManifest };
  }

  return { valid: false, errors: result.errors };
}
