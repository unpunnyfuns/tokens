/**
 * Functional token validation API
 */

import Ajv from "ajv/dist/2020.js";
import type { TokenDocument } from "../types.js";
import type { ValidationError, ValidationResult } from "../types/validation.js";
import { hasReferences } from "../references/index.js";

// Import base schemas
import baseSchema from "../schemas/tokens/base.schema.json" with {
  type: "json",
};
import tokenSchema from "../schemas/tokens/full.schema.json" with {
  type: "json",
};
import valueTypesSchema from "../schemas/tokens/value-types.schema.json" with {
  type: "json",
};

// Import type schemas
import borderSchema from "../schemas/tokens/types/border.schema.json" with {
  type: "json",
};
import colorSchema from "../schemas/tokens/types/color.schema.json" with {
  type: "json",
};
import cubicBezierSchema from "../schemas/tokens/types/cubic-bezier.schema.json" with {
  type: "json",
};
import dimensionSchema from "../schemas/tokens/types/dimension.schema.json" with {
  type: "json",
};
import durationSchema from "../schemas/tokens/types/duration.schema.json" with {
  type: "json",
};
import fontFamilySchema from "../schemas/tokens/types/font-family.schema.json" with {
  type: "json",
};
import fontWeightSchema from "../schemas/tokens/types/font-weight.schema.json" with {
  type: "json",
};
import gradientSchema from "../schemas/tokens/types/gradient.schema.json" with {
  type: "json",
};
import numberSchema from "../schemas/tokens/types/number.schema.json" with {
  type: "json",
};
import shadowSchema from "../schemas/tokens/types/shadow.schema.json" with {
  type: "json",
};
import strokeStyleSchema from "../schemas/tokens/types/stroke-style.schema.json" with {
  type: "json",
};
import transitionSchema from "../schemas/tokens/types/transition.schema.json" with {
  type: "json",
};
import typographySchema from "../schemas/tokens/types/typography.schema.json" with {
  type: "json",
};

/**
 * Validation options
 */
export interface TokenValidationOptions {
  /** Use strict DTCG validation (default: true) */
  strict?: boolean;
  /** Check that references exist (default: false) */
  validateReferences?: boolean;
  /** Maximum number of errors to collect (default: 100) */
  errorLimit?: number;
}

// Cache compiled validators
const validatorCache = new Map<string, ReturnType<Ajv.default["compile"]>>();
let ajvInstance: Ajv.default | null = null;

/**
 * Get or create AJV instance
 */
function getAjv(): Ajv.default {
  if (!ajvInstance) {
    ajvInstance = new Ajv.default({
      allErrors: true,
      verbose: true,
      strict: false,
    });

    // Add all schemas
    const schemas = [
      baseSchema,
      valueTypesSchema,
      colorSchema,
      dimensionSchema,
      fontFamilySchema,
      fontWeightSchema,
      durationSchema,
      numberSchema,
      shadowSchema,
      typographySchema,
      cubicBezierSchema,
      strokeStyleSchema,
      borderSchema,
      transitionSchema,
      gradientSchema,
    ];

    for (const schema of schemas) {
      ajvInstance.addSchema(schema);
    }
  }

  return ajvInstance;
}

/**
 * Get compiled validator for a schema
 */
function getValidator(schemaId: string): ReturnType<Ajv.default["compile"]> {
  const cached = validatorCache.get(schemaId);
  if (cached) return cached;

  const ajv = getAjv();
  const validator = ajv.compile(
    schemaId === "full" ? tokenSchema : { type: "object" },
  );
  validatorCache.set(schemaId, validator);
  return validator;
}

/**
 * Format AJV errors to our error format
 */
function formatAjvErrors(
  errors: Ajv.ErrorObject[],
  limit = 100,
): ValidationError[] {
  return errors.slice(0, limit).map((error) => ({
    path: error.instancePath || "/",
    message:
      error.message || `Validation failed at ${error.instancePath || "root"}`,
    severity: "error" as const,
    rule: error.keyword,
    context: error.params,
  }));
}

/**
 * Check if references in a document exist
 */
function checkReferences(document: TokenDocument): ValidationError[] {
  const errors: ValidationError[] = [];
  const tokenPaths = new Set<string>();

  // Collect all token paths
  function collectPaths(obj: unknown, path = ""): void {
    if (!obj || typeof obj !== "object") return;

    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;

      if (value && typeof value === "object" && "$value" in value) {
        tokenPaths.add(currentPath);
      }

      if (value && typeof value === "object" && !("$value" in value)) {
        collectPaths(value, currentPath);
      }
    }
  }

  collectPaths(document);

  // Check references
  function checkRefs(obj: unknown, path = ""): void {
    if (!obj || typeof obj !== "object") return;

    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;

      // Check for references in the value
      if (hasReferences(value)) {
        // Extract reference paths
        const refs = extractReferencePaths(value);
        for (const ref of refs) {
          if (!tokenPaths.has(ref)) {
            errors.push({
              path: `/${currentPath.replace(/\./g, "/")}`,
              message: `Reference to non-existent token: ${ref}`,
              severity: "error",
              rule: "reference-exists",
            });
          }
        }
      }

      // Recurse into objects
      if (value && typeof value === "object" && !Array.isArray(value)) {
        checkRefs(value, currentPath);
      }
    }
  }

  checkRefs(document);
  return errors;
}

/**
 * Extract reference paths from a value
 */
function extractReferencePaths(value: unknown): string[] {
  const paths: string[] = [];

  if (typeof value === "string") {
    // DTCG format: {path.to.token}
    const dtcgMatch = value.match(/^\{([^}]+)\}$/);
    if (dtcgMatch) {
      paths.push(dtcgMatch[1]);
    }
    return paths;
  }

  if (value && typeof value === "object") {
    // JSON Schema $ref format
    const objValue = value as Record<string, unknown>;
    if ("$ref" in objValue && typeof objValue.$ref === "string") {
      const refPath = objValue.$ref.replace(/^#\//, "").replace(/\//g, ".");
      paths.push(refPath);
    }

    // Recurse into nested values
    for (const v of Object.values(objValue)) {
      paths.push(...extractReferencePaths(v));
    }
  }

  return paths;
}

/**
 * Validate a token document
 */
export async function validateTokenDocument(
  document: unknown,
  options: TokenValidationOptions = {},
): Promise<ValidationResult> {
  const {
    strict = true,
    validateReferences = false,
    errorLimit = 100,
  } = options;

  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];

  // Schema validation
  if (strict) {
    const validator = getValidator("full");
    const valid = validator(document);

    if (!valid && validator.errors) {
      errors.push(...formatAjvErrors(validator.errors, errorLimit));
    }
  }

  // Reference validation
  if (validateReferences && document && typeof document === "object") {
    const refErrors = checkReferences(document as TokenDocument);
    errors.push(...refErrors.slice(0, errorLimit - errors.length));
  }

  return {
    valid: errors.length === 0,
    errors: errors.slice(0, errorLimit),
    warnings: warnings.slice(0, errorLimit),
  };
}

/**
 * Validate multiple token documents
 */
export async function validateTokenDocuments(
  documents: unknown[],
  options: TokenValidationOptions = {},
): Promise<ValidationResult[]> {
  return Promise.all(
    documents.map((doc) => validateTokenDocument(doc, options)),
  );
}

/**
 * Check if a value is a valid token document (quick check)
 */
export function isValidTokenDocument(document: unknown): boolean {
  if (!document || typeof document !== "object") return false;

  // Quick structural check - must be an object with token-like structure
  const hasTokenStructure = (obj: unknown): boolean => {
    if (!obj || typeof obj !== "object") return false;

    for (const value of Object.values(obj)) {
      // Either has $value (is a token) or contains nested tokens
      if (value && typeof value === "object") {
        if ("$value" in value) return true;
        if (hasTokenStructure(value)) return true;
      }
    }
    return false;
  };

  return hasTokenStructure(document);
}
