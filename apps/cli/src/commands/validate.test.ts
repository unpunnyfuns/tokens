/**
 * Unit tests for validate command implementation
 */

import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import {
  validateDirectory,
  validateManifestObject,
  validateTokenFile,
} from "./validate.js";

// Mock dependencies
vi.mock("@upft/analysis");
vi.mock("@upft/loader");
vi.mock("node:fs", () => ({
  promises: {
    readFile: vi.fn(),
    readdir: vi.fn(),
    stat: vi.fn(),
  },
}));

import { promises as fs } from "node:fs";
import { analyzeTokens } from "@upft/analysis";
import { runPipeline } from "@upft/loader";

const mockAnalyzeTokens = vi.mocked(analyzeTokens);
const mockRunPipeline = vi.mocked(runPipeline);
const mockReadFile = vi.mocked(fs.readFile);
const mockReaddir = vi.mocked(fs.readdir);
const mockStat = vi.mocked(fs.stat);

describe("validate commands", () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Setup default successful analysis
    mockAnalyzeTokens.mockReturnValue({
      unresolvedReferences: [],
      circularReferences: [],
      tokenCount: 1,
      typeDistribution: { color: 1 },
    });

    // Setup default successful pipeline
    mockRunPipeline.mockResolvedValue({
      project: { name: "Test", sets: [], modifiers: {} },
      errors: [],
      warnings: [],
    });

    // Setup default file reading
    mockReadFile.mockResolvedValue(
      '{"test": {"$type": "color", "$value": "#000"}}',
    );
    // JSON.parse is used directly, no need to mock
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe("validateTokenFile", () => {
    it("should validate a token file successfully", async () => {
      const result = await validateTokenFile("/path/to/tokens.json");

      expect(mockReadFile).toHaveBeenCalledWith(
        "/path/to/tokens.json",
        "utf-8",
      );
      expect(mockAnalyzeTokens).toHaveBeenCalledWith({
        test: { $type: "color", $value: "#000" },
      });
      expect(result).toEqual({
        valid: true,
        errors: [],
        warnings: [],
      });
    });

    it("should handle validation errors", async () => {
      mockAnalyzeTokens.mockReturnValue({
        unresolvedReferences: ["color.missing"],
        circularReferences: ["color.circular"],
        tokenCount: 1,
        typeDistribution: { color: 1 },
      });

      const result = await validateTokenFile("/path/to/invalid-tokens.json");

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: "Unresolved reference: color.missing",
            path: "/path/to/invalid-tokens.json",
            severity: "error",
          },
          {
            message: "Circular reference detected: color.circular",
            path: "/path/to/invalid-tokens.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should handle file reading errors", async () => {
      mockReadFile.mockRejectedValue(new Error("File not found"));

      const result = await validateTokenFile("/nonexistent/file.json");

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: "File not found",
            path: "/nonexistent/file.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should handle JSON parsing errors", async () => {
      mockReadFile.mockResolvedValue('{"invalid": json}');

      const result = await validateTokenFile("/path/to/malformed.json");

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: expect.stringContaining("Unexpected token"),
            path: "/path/to/malformed.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should handle validation warnings", async () => {
      // In the current implementation, warnings are not generated by analyzeTokens
      // This test verifies that files without errors are considered valid
      const result = await validateTokenFile("/path/to/tokens.json");

      expect(result).toEqual({
        valid: true,
        errors: [],
        warnings: [],
      });
    });

    it("should handle empty token file", async () => {
      mockReadFile.mockResolvedValue("{}");

      const result = await validateTokenFile("/path/to/empty.json");

      expect(mockAnalyzeTokens).toHaveBeenCalledWith({});
      expect(result.valid).toBe(true);
    });

    it("should handle complex token structures", async () => {
      const complexTokens = {
        color: {
          primary: { $type: "color", $value: "#007bff" },
          secondary: { $type: "color", $value: "#6c757d" },
        },
        dimension: {
          spacing: {
            small: { $type: "dimension", $value: "8px" },
            medium: { $type: "dimension", $value: "16px" },
          },
        },
      };

      mockReadFile.mockResolvedValue(JSON.stringify(complexTokens));
      mockAnalyzeTokens.mockReturnValue({
        unresolvedReferences: [],
        circularReferences: [],
        tokenCount: 4,
        typeDistribution: { color: 2, dimension: 2 },
      });

      const result = await validateTokenFile("/path/to/complex-tokens.json");

      expect(mockAnalyzeTokens).toHaveBeenCalledWith(complexTokens);
      expect(result.valid).toBe(true);
    });
  });

  describe("validateManifestObject", () => {
    it("should validate a manifest file successfully", async () => {
      const result = await validateManifestObject("/path/to/manifest.json");

      expect(mockRunPipeline).toHaveBeenCalledWith("/path/to/manifest.json", {
        basePath: "/path/to",
        validate: true,
        parseToAST: true,
      });
      expect(result).toEqual({
        valid: true,
        errors: [],
        warnings: [],
      });
    });

    it("should handle manifest validation errors", async () => {
      const mockErrors = [
        "Missing sets array",
        "Invalid modifier configuration",
      ];

      mockRunPipeline.mockResolvedValue({
        project: { name: "Invalid", sets: [], modifiers: {} },
        errors: mockErrors,
        warnings: [],
      });

      const result = await validateManifestObject(
        "/path/to/invalid-manifest.json",
      );

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: "Missing sets array",
            path: "/path/to/invalid-manifest.json",
            severity: "error",
          },
          {
            message: "Invalid modifier configuration",
            path: "/path/to/invalid-manifest.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should handle complex manifest with modifiers", async () => {
      const mockProject = {
        name: "Complex Manifest",
        sets: [
          {
            name: "base",
            files: ["/tokens/base/**/*.json"],
          },
          {
            name: "theme",
            files: ["/tokens/themes/{theme}/**/*.json"],
          },
        ],
        modifiers: {
          theme: {
            type: "select",
            options: ["light", "dark"],
          },
        },
      };

      mockRunPipeline.mockResolvedValue({
        project: mockProject,
        errors: [],
        warnings: [],
      });

      const result = await validateManifestObject(
        "/path/to/complex-manifest.json",
      );

      expect(result.valid).toBe(true);
    });

    it("should handle manifest reading errors", async () => {
      mockRunPipeline.mockRejectedValue(new Error("Access denied"));

      const result = await validateManifestObject("/restricted/manifest.json");

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: "Failed to validate manifest: Access denied",
            path: "/restricted/manifest.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should handle malformed manifest JSON", async () => {
      mockRunPipeline.mockRejectedValue(
        new Error("Unexpected end of JSON input"),
      );

      const result = await validateManifestObject(
        "/path/to/malformed-manifest.json",
      );

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message:
              "Failed to validate manifest: Unexpected end of JSON input",
            path: "/path/to/malformed-manifest.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });
  });

  describe("validateDirectory", () => {
    beforeEach(() => {
      // Setup directory structure mocking
      mockStat.mockImplementation((path) => {
        if (path.includes("directory")) {
          return Promise.resolve({ isDirectory: () => true });
        }
        return Promise.resolve({ isDirectory: () => false });
      });
    });

    it("should validate all token files in a directory", async () => {
      const mockFiles = [
        "colors.json",
        "typography.json",
        "spacing.json",
        "readme.md", // Should be ignored
        "subdirectory", // Should be ignored
      ];

      mockReaddir.mockResolvedValue(mockFiles as any);

      const result = await validateDirectory("/path/to/tokens");

      expect(mockReaddir).toHaveBeenCalledWith("/path/to/tokens");
      // Only JSON files are processed, so 3 calls to readFile and analyzeTokens
      expect(mockReadFile).toHaveBeenCalledTimes(3);
      expect(mockAnalyzeTokens).toHaveBeenCalledTimes(3);
      expect(result.valid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it("should collect validation errors from multiple files", async () => {
      const mockFiles = ["valid.json", "invalid.json"];

      mockReaddir.mockResolvedValue(mockFiles as any);

      mockAnalyzeTokens
        .mockReturnValueOnce({
          unresolvedReferences: [],
          circularReferences: [],
          tokenCount: 1,
          typeDistribution: { color: 1 },
        })
        .mockReturnValueOnce({
          unresolvedReferences: ["color.missing"],
          circularReferences: [],
          tokenCount: 1,
          typeDistribution: { color: 1 },
        });

      const result = await validateDirectory("/path/to/tokens");

      expect(result.valid).toBe(false);
      expect(result.errors).toEqual([
        {
          message: "Unresolved reference: color.missing",
          path: "/path/to/tokens/invalid.json",
          severity: "error",
        },
      ]);
    });

    it("should handle empty directory", async () => {
      mockReaddir.mockResolvedValue([]);

      const result = await validateDirectory("/path/to/empty");

      expect(result.valid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it("should handle directory reading errors", async () => {
      mockReaddir.mockRejectedValue(new Error("Permission denied"));

      const result = await validateDirectory("/restricted/directory");

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: "Permission denied",
            path: "/restricted/directory",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should handle file validation errors within directory", async () => {
      const mockFiles = ["broken.json"];

      mockReaddir.mockResolvedValue(mockFiles as any);
      mockReadFile.mockRejectedValue(new Error("File corrupted"));

      const result = await validateDirectory("/path/to/tokens");

      expect(result).toEqual({
        valid: false,
        errors: [
          {
            message: "File corrupted",
            path: "/path/to/tokens/broken.json",
            severity: "error",
          },
        ],
        warnings: [],
      });
    });

    it("should ignore non-JSON files", async () => {
      const mockFiles = [
        "tokens.json",
        "README.md",
        "config.yaml",
        "script.js",
        "styles.css",
        "data.txt",
      ];

      mockReaddir.mockResolvedValue(mockFiles as any);

      const result = await validateDirectory("/path/to/mixed");

      expect(mockReadFile).toHaveBeenCalledTimes(1); // Only tokens.json
      expect(mockAnalyzeTokens).toHaveBeenCalledTimes(1);
      expect(result.valid).toBe(true);
    });

    it("should handle directories with only subdirectories", async () => {
      const mockFiles = ["subdir1", "subdir2"];

      mockReaddir.mockResolvedValue(mockFiles as any);

      const result = await validateDirectory("/path/to/only-dirs");

      expect(mockReadFile).not.toHaveBeenCalled();
      expect(mockAnalyzeTokens).not.toHaveBeenCalled();
      expect(result.valid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it("should handle mixed success and failure scenarios", async () => {
      const mockFiles = ["success.json", "failure.json"];

      mockReaddir.mockResolvedValue(mockFiles as any);

      mockReadFile
        .mockResolvedValueOnce(
          '{"valid": {"$type": "color", "$value": "#000"}}',
        )
        .mockResolvedValueOnce(
          '{"invalid": {"$type": "color", "$value": "not-a-color"}}',
        );

      mockAnalyzeTokens
        .mockReturnValueOnce({
          unresolvedReferences: [],
          circularReferences: [],
          tokenCount: 1,
          typeDistribution: { color: 1 },
        })
        .mockReturnValueOnce({
          unresolvedReferences: ["color.missing"],
          circularReferences: [],
          tokenCount: 1,
          typeDistribution: { color: 1 },
        });

      const result = await validateDirectory("/path/to/tokens");

      expect(result.valid).toBe(false);
      expect(result.errors).toEqual([
        {
          message: "Unresolved reference: color.missing",
          path: "/path/to/tokens/failure.json",
          severity: "error",
        },
      ]);
    });
  });

  describe("edge cases", () => {
    it("should handle very large token files", async () => {
      const largeTokens = {};
      for (let i = 0; i < 10; i++) {
        // Reduced for test performance
        (largeTokens as any)[`token${i}`] = {
          $type: "color",
          $value: `#${i.toString(16).padStart(6, "0")}`,
        };
      }

      mockReadFile.mockResolvedValue(JSON.stringify(largeTokens));
      mockAnalyzeTokens.mockReturnValue({
        unresolvedReferences: [],
        circularReferences: [],
        tokenCount: 10,
        typeDistribution: { color: 10 },
      });

      const result = await validateTokenFile("/path/to/large-tokens.json");

      expect(mockAnalyzeTokens).toHaveBeenCalledWith(largeTokens);
      expect(result.valid).toBe(true);
    });

    it("should handle special characters in file paths", async () => {
      const specialPath = "/path/with spaces/and-special_chars/tokens (1).json";

      const result = await validateTokenFile(specialPath);

      expect(mockReadFile).toHaveBeenCalledWith(specialPath, "utf-8");
      expect(result.valid).toBe(true);
    });
  });
});
